# -*- coding: utf-8 -*-
"""Taller 4.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1wP3FGOmP9SpXWJirnws5Dg1JdDEVQ3Dp

Integrantes taller 4: 
Juan Pablo Montoya, 
Daniel Vanegas Gómez,
Carlos Andres Sepulveda
"""

!wget --no-cache -O init.py -q https://raw.githubusercontent.com/UDEA-Esp-Analitica-y-Ciencia-de-Datos/EACD-01-FUNDAMENTOS/master/init.py
import init; init.init(force_download=False);

"""# Precios de Casas

El objetivo de este taller es realizar un análisis exploratorio de un dataset. El dataset no llega limpio, el proceso de limpieza se encuentra implementado. Después de este proceso de limpieza se debe llevar a cabo el análisis exploratorio.
"""

from collections import Counter, defaultdict

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt

pd.set_option("display.max_rows", None, "display.max_columns", None)

"""## Entendiendo y limpiando el dataset

La descripcion de cada variable puede verse ejecutando la siguiente celda
"""

!cat local/data/houseprices_description.txt

"""Ahora carguemos los datos y hagamos una breve exploración"""

df = pd.read_csv("local/data/houseprices.csv")
df.head()

df.info()

"""Podemos ver que hay una gran cantidad de valores nulos en algunas de las variables. Alguien, algo despistado, podría sugerir simplemente eliminar esas variables; sin embargo, la descripción de las variables que observamos anteriormente, nos permite entender la razón de ser de estos valores nulos y tratarlos de una manera inteligente. Por ejemplo, consideremos la variable `PoolQC` la cual nos muestra únicamente 7 valores no nulos de los 1460 registros que tenemos en total. Su descripción dice:

```
PoolQC: Pool quality
		
       Ex	Excellent
       Gd	Good
       TA	Average/Typical
       Fa	Fair
       NA	No Pool

```

Esta variable hace referencia a la calidad de la piscina en la casa y vemos que `NA` significa que no tiene piscina, lo cual posiblemente tiene mucho impacto en el precio de una casa (pregúntese, ¿estaría dispuesto a pagar más por una casa que tenga piscina?). Además, vemos que existe la variable `PoolArea`, la cual almacena el area de la piscina en $ft^2$, la cual no tiene valores nulos. Dado esto, los valores nulos de la variable `PoolQC` deben corresponder a casos en los que la variable `PoolArea` es cero; validemos esto.
"""

num_total_nulls = df["PoolQC"].isna().sum()
num_nulls_when_poolarea_is_zero = df[df["PoolArea"] == 0]["PoolQC"].isna().sum()
assert num_nulls_when_poolarea_is_zero == num_total_nulls

num_nulls_when_poolarea_is_not_zero = df[df["PoolArea"] != 0]["PoolQC"].isna().sum()
assert num_nulls_when_poolarea_is_not_zero == 0

"""Concluimos que se cumple que todos los valores nulos de la variable `PoolQC` corresponden a casos en los que no hay piscina; por lo tanto, vamos a reemplzar los valores nulos por otro valor que podamos usar en nuestros modelos."""

df["PoolQC"] = df["PoolQC"].fillna("NP")

"""Esta misma lógica debemos usarla a la hora de tratar el resto de las variables con valores nulos de este dataset. Escribiremos algún razonamiento addiconal únicamente cuando haga falta"""

num_total_nulls = df["MiscFeature"].isna().sum()
num_nulls_when_miscval_is_zero = df[df["MiscVal"] == 0]["MiscFeature"].isna().sum()
num_nulls_when_miscval_is_not_zero = df[df["MiscVal"] != 0]["MiscFeature"].isna().sum()
assert num_nulls_when_miscval_is_zero == num_total_nulls
assert num_nulls_when_miscval_is_not_zero == 0
df["MiscFeature"] = df["MiscFeature"].fillna("No MF")

num_total_nulls = df["FireplaceQu"].isna().sum()
num_nulls_when_fireplaces_is_zero = df[df["Fireplaces"] == 0]["FireplaceQu"].isna().sum()
num_nulls_when_fireplaces_is_not_zero = df[df["Fireplaces"] != 0]["FireplaceQu"].isna().sum()
assert num_nulls_when_fireplaces_is_zero == num_total_nulls
assert num_nulls_when_fireplaces_is_not_zero == 0
df["FireplaceQu"] = df["FireplaceQu"].fillna("No FP")

num_area_zeros = (df["GarageArea"] == 0).sum()
num_cars_zeros = (df["GarageCars"] == 0).sum()
num_both_zeros = ((df["GarageArea"] == 0) & (df["GarageCars"] == 0.0)).sum()
assert num_both_zeros == num_area_zeros == num_cars_zeros
for colname in ["GarageType", "GarageFinish", "GarageQual", "GarageCond"]:
    num_total_nulls = df[colname].isna().sum()
    num_nulls_when_area_and_cars_capacity_is_zero = df[(df["GarageArea"] == 0.0) & (df["GarageCars"] == 0.0)][colname].isna().sum()
    num_nulls_when_area_and_cars_capacity_is_not_zero = df[(df["GarageArea"] != 0.0) & (df["GarageCars"] != 0.0)][colname].isna().sum()
    assert num_total_nulls == num_nulls_when_area_and_cars_capacity_is_zero
    assert num_nulls_when_area_and_cars_capacity_is_not_zero == 0
    df[colname] = df[colname].fillna("No Ga")

"""Para la variable `GarageYrBlt` debemos ser más cuidadosos, ya que son números y no strings. Esta variable nos dice el año en que fue construido el garaje y, según lo visto con otras variables relacionadas al garage, los valores nulos corresponden a casos en los que no hay garage. En este caso, vamos a imputar esa variable con un año posterior a la fecha de venta. Esta aproximación podría no funcionar muy bien con modelos lineales, o cuando escalamos los datos, pero no se me ocurre otra!"""

num_total_nulls = df["GarageYrBlt"].isna().sum()
num_nulls_when_area_and_cars_is_zero = df[(df["GarageArea"] == 0.0) & (df["GarageCars"] == 0.0)]["GarageYrBlt"].isna().sum()
num_nulls_when_area_and_cars_is_not_zero = df[(df["GarageArea"] != 0.0) & (df["GarageCars"] != 0.0)]["GarageYrBlt"].isna().sum()
assert num_nulls_when_area_and_cars_is_zero == num_total_nulls
assert num_nulls_when_area_and_cars_is_not_zero == 0
df["GarageYrBlt"].where(~df["GarageYrBlt"].isna(), other=df["YrSold"] + 1, inplace=True)

"""`LotFrontage: Linear feet of street connected to property)`

Valores nulos en esta variable podrían ser ocasionados porque sencillamente no hay conexión de la calle a la propiedad, es decir, que esa longitud medida por esta variable es igual a 0. Podemos asumir que este es el caso únicamente si no hay otro 0 en los valores que ha tomado esta variable, de otra manera ¿por qué algunos tendrían 0 y otros nulos?
"""

assert (df["LotFrontage"] == 0).sum() == 0
df["LotFrontage"].fillna(0, inplace=True)

df["Alley"].fillna("NA", inplace=True)
df["Fence"].fillna("NF", inplace=True)

"""```
MasVnrType: Masonry veneer type

       BrkCmn	Brick Common
       BrkFace	Brick Face
       CBlock	Cinder Block
       None	None
       Stone	Stone
	
MasVnrArea: Masonry veneer area in square feet
```

Una posibilidad es que los valores nulos de `MasVnrType` y `MasVnrArea` correspondan a casos en los que no hay "Masonry veneer" (chapa de albañilería). Esto sería en los casos en que la variable `MasVnrArea` sea 0, esto lo validaremos de la misma manera en que validamos con la variable `LotFrontage`.
"""

assert (df["MasVnrArea"] == 0).sum() == df["MasVnrType"].isnull().sum()

"""Acá la situación es diferente, el error anterior nos dice que los casos para los cuales no tenemos área son distintos de los que el tipo es nulo, entonces nos toca inspeccionar más en detalle. Sabemos que hay 8 valores nulos en cada una de las dos variables, miremos si corresponden a los mismos registros:"""

np.logical_and(df["MasVnrType"].isnull().values, df["MasVnrArea"].isnull().values).sum()

"""En efecto, dado que hay 8 registros para los cuales las dos variables tienen valores nulos, podemos decir que son nulos en ambas partes. A falta de información, vamos a decidir eliminar esos registros por completo, no debe ser muy grave, pues apenas son 8 filas en todo el dataset."""

df = df.dropna(subset=["MasVnrType", "MasVnrArea"])

"""Ahora miremos los valores de cada una"""

df["MasVnrType"].value_counts()

df["MasVnrArea"].value_counts()

"""Acá podemos observar lo siguiente:
- Hay 864 registros con `MasVnrType="None"`
- Hay 861 registros con `MasVnrArea=0`

Eso quiere decir que hay algunos registros que deberían tener un área de 0 y no es así. Vamos a mirar en detalle cuáles son:
"""

df[(df["MasVnrType"] == "None") & (df["MasVnrArea"] != 0.0)]

"""**Francamente** yo no soy un experto en casas, por lo que no tengo forma de deducir a qué se debe esa incoherencia en los datos. Por lo anterior, simplemente voy a eliminar esas filas, ya que tengo dudas de la veracidad de esos datos."""

df = df[~((df["MasVnrType"] == "None") & (df["MasVnrArea"] != 0.0))]

"""La variable `Electrical` tampoco nos ofrece una forma de recuperar esos valores nulos, por lo que también vamos a eliminar ese registro. Nótese que otra opción podría ser reemplazarlo con el valor más común en la misma variable, dado que esta es categórica. """

df.dropna(subset=["Electrical"], inplace=True)

df.info()

"""Ahora miremos las variables relacionadas con el basement:

```

BsmtQual: Evaluates the height of the basement

       Ex	Excellent (100+ inches)	
       Gd	Good (90-99 inches)
       TA	Typical (80-89 inches)
       Fa	Fair (70-79 inches)
       Po	Poor (<70 inches
       NA	No Basement
		
BsmtCond: Evaluates the general condition of the basement

       Ex	Excellent
       Gd	Good
       TA	Typical - slight dampness allowed
       Fa	Fair - dampness or some cracking or settling
       Po	Poor - Severe cracking, settling, or wetness
       NA	No Basement
	
BsmtExposure: Refers to walkout or garden level walls

       Gd	Good Exposure
       Av	Average Exposure (split levels or foyers typically score average or above)	
       Mn	Mimimum Exposure
       No	No Exposure
       NA	No Basement
	
BsmtFinType1: Rating of basement finished area

       GLQ	Good Living Quarters
       ALQ	Average Living Quarters
       BLQ	Below Average Living Quarters	
       Rec	Average Rec Room
       LwQ	Low Quality
       Unf	Unfinshed
       NA	No Basement
		
BsmtFinSF1: Type 1 finished square feet

BsmtFinType2: Rating of basement finished area (if multiple types)

       GLQ	Good Living Quarters
       ALQ	Average Living Quarters
       BLQ	Below Average Living Quarters	
       Rec	Average Rec Room
       LwQ	Low Quality
       Unf	Unfinshed
       NA	No Basement

BsmtFinSF2: Type 2 finished square feet

BsmtUnfSF: Unfinished square feet of basement area

TotalBsmtSF: Total square feet of basement area

```

Dado que los valores nulos en varias de estas variables corresponden a `No Basement`, ahora miremos si los registros nulos en algunas corresponden a los registros nulos en todas. Primero, dado que ya hemos eliminado varios registros, vamos a ver cuántos valores nulos hay en esas variables.
"""

colnames = ["BsmtQual", "BsmtCond", "BsmtExposure", "BsmtFinType1",
    "BsmtFinSF1", "BsmtFinType2", "BsmtFinSF2", "BsmtUnfSF", "TotalBsmtSF"]
for c in colnames:
    print(f"{c} has {df[c].isnull().sum()} null values")

df["TotalBsmtSF"].value_counts()

"""Acá vemos que algunas tienen más variables nulas que otras, lo cual es confuso porque en cualquier caso los valores nulos deberían significar que no hay basement. En este caso vamos a reemplazar los valores en los que los valores nulos sean en todas las variables no numéricas pero los que sobren los eliminaremos."""

colnames = ["BsmtQual", "BsmtCond", "BsmtExposure", "BsmtFinType1", "BsmtFinType2"]
cond = ~(df["BsmtQual"].isna() & df["BsmtCond"].isna() & df["BsmtExposure"].isna() & df["BsmtFinType1"].isna() & df["BsmtFinType2"].isna())
for c in colnames:
    df[c].where(cond, other="NB", inplace=True)

df.dropna(inplace=True)
print(f"Number of null values {df.isna().sum().sum()} in a dataframe of shape {df.shape}")

"""## Análisis exploratorio de datos

En esta sección se dejarán preguntas que deben ser respondidas utilizando los datos.

**¿Qué tan viejas son las casas?**
"""

df["HouseAge"] = df["YrSold"] - df["YearBuilt"]
df["HouseAge"].hist(bins=20)

"""¿Cómo se relaciona el precio con la edad de la casa?**

Para esta pregunta se hizo un scatterplot de precio vs la edad de la casa.  Obteniendo como resultado que existe una correlación de precio vs vetustez, debido a que mientras más antigua sea la casa, menor es su precio.
"""

df[["HouseAge","SalePrice"]].plot.scatter(x="HouseAge", y="SalePrice")

print(df[["HouseAge"]].mean())
print(df[["SalePrice"]].mean())

"""**¿Cuál es el barrio más pobre?**

Para calcular el barrio más pobre tomamos tres variables, Overall total, Overall Qual y Overall Cond y el barrio, donde logramos identificar que MEadowV es el barrio más pobre debido a que es el de menor cualificación de acuerdo al resto de barrios, tomando la suma de OverallQual y OverallCond.
"""

df["overall_total"]=df["OverallQual"]+df["OverallCond"]
df.groupby(["Neighborhood"])["overall_total"].mean().reset_index().sort_values(by="overall_total",ascending=True).head(10)

df.groupby(["Neighborhood"])["overall_total"].mean().reset_index().sort_values(by="overall_total",ascending=True).plot.bar(x="Neighborhood", y="overall_total", figsize=(19,5), ylabel="Calidad-Condición Total de las viviendas", title="Barrios con mejor condición y calidad en general ", color="g")

print("IDOTRR")
print('Número total de casas')
print(df[df["Neighborhood"]=="IDOTRR"].count()[0])
print("porcentaje de Casas sin garaje")
print((df[(df["Neighborhood"]=="IDOTRR") & (df["GarageQual"]=="No Ga")]["Id"].count()/df[df["Neighborhood"]=="IDOTRR"].count()[0]*100).round(2))
print("porcentaje de Casas sin piscina")
print((df[(df["Neighborhood"]=="IDOTRR") & (df["PoolQC"]=="NP")]["Id"].count()/df[df["Neighborhood"]=="IDOTRR"].count()[0]*100).round(2))
print("porcentaje de Casas sin chimenea")
print((df[(df["Neighborhood"]=="IDOTRR") & (df["Fireplaces"]==0)]["Id"].count()/df[df["Neighborhood"]=="IDOTRR"].count()[0]*100).round(2))
print("media de año de las casas")
print(df[(df["Neighborhood"]=="IDOTRR")]["HouseAge"].mean())

print("MeadowV")
print('Número total de casas')
print(df[df["Neighborhood"]=="MeadowV"].count()[0])
print("porcentaje de Casas sin garaje")
print((df[(df["Neighborhood"]=="MeadowV") & (df["GarageQual"]=="No Ga")]["Id"].count()/df[df["Neighborhood"]=="MeadowV"].count()[0]*100).round(2))
print("porcentaje de Casas sin piscina")
print((df[(df["Neighborhood"]=="MeadowV") & (df["PoolQC"]=="NP")]["Id"].count()/df[df["Neighborhood"]=="MeadowV"].count()[0]*100).round(2))
print("porcentaje de Casas sin chimenea")
print((df[(df["Neighborhood"]=="MeadowV") & (df["Fireplaces"]==0)]["Id"].count()/df[df["Neighborhood"]=="MeadowV"].count()[0]*100).round(2))
print("media de año de las casas")
print(df[(df["Neighborhood"]=="MeadowV")]["HouseAge"].mean())

"""**¿Cuál es el barrio más cercano a vías férreas?**

En este caso logramos utilizar Condition1 y Condition2 como parametros y tomamos los valores de RRNn, RRAn, RRNe, RRAe, para identificar la distancias con las vías ferreas tomando estos valores como un total, luego graficamos estos valores lograbdo identificar que el barrio más cercano a vías ferreas es BrrkSide.
"""

df["SUMA_FERREA_1"]=df[["Condition1"]].apply(lambda x: 1 if ((x["Condition1"]=="RRAn") or (x["Condition1"]=="RRNn") or (x["Condition1"]=="RRNe") or (x["Condition1"]=="RRAe")) else 0, axis=1)
df["SUMA_FERREA_2"]=df[["Condition2"]].apply(lambda x: 1 if ((x["Condition2"]=="RRAn") or (x["Condition2"]=="RRNn") or (x["Condition2"]=="RRNe") or (x["Condition2"]=="RRAe")) else 0, axis=1)
df["SUMA_FERREA_TOTAL"]=df["SUMA_FERREA_1"]+df["SUMA_FERREA_2"]

df.groupby(["Neighborhood"])["SUMA_FERREA_TOTAL"].mean().reset_index().sort_values(by="SUMA_FERREA_TOTAL",ascending=False).rename(columns={"SUMA_FERREA_TOTAL":"CERCANÍA A VÍAS FERREAS"}).head(10).plot.bar(x="Neighborhood", y="CERCANÍA A VÍAS FERREAS", figsize=(13,4), color="y", title="Barrios más cercanos a vías ferreas", ylabel="Promedio cercanía a vías ferreas")



"""**¿Cuál es la cobertura más común en las casas que se encuentran el el top 10% en precio?**

Para identificar la cobertura (techo) más común de las casas más caras, que están en el top 10 en precio, tomamos los materiales más comunes entre este tipo de casa, luego tomamos los estilos más comunes entre estas casas costosas y finalmente las cubiertas de exteriores más comunes identificando que el material más común es el VinylSd y el material más común es el CompShg
"""

percentil90=np.percentile(df[["SalePrice"]].sort_values(by="SalePrice", ascending=False),90)
top10percent=df[df["SalePrice"]>=percentil90]
print("Estos son los materiales más comunes entre el 10% de las casa mas costosas")

print(top10percent["RoofMatl"].value_counts())

print("Estos son los estilos más comunes entre el 10% de las casa mas costosas")

print(top10percent["RoofStyle"].value_counts())

print("Estos son las cubiertas exteriores más comunes entre el 10% de las casa mas costosas")

print(top10percent["Exterior1st"].value_counts())

print("Estos son los cubiertas exteriores secundarias más comunes entre el 10% de las casa mas costosas")

print(top10percent["Exterior2nd"].value_counts())

"""**¿En qué barrio hay mayor desigualdad?**

Para determinar el barrio que es más desigual, asignamos un valor numérico a algunas variables categóricas de carácter externo, es decir variables que no dependen de la casa si no que provienen de servicios o facilidades que provee el sector, que se consideran importantes para determinar desigualdad, de forma tal que nos permitiera ponderar por casa y barrio estas variables.


Las variables que se seleccionaron como determinantes de desigualdad son:\
*Alley*\
*Utilities*\
*OverallQuall* -- **No es categórica** \
*OverallCond* -- **No es categórica**\
*ExterQual*\
*ExterCond*\
*KitchenQual*\
*Functional* \

Los valores asignados a las variables categóricas irán desde 1, siendo esta la peor condición, hasta el número que aplique en cada caso según el número de descripciones.

Dando como resultado que el barrio mas desigual es Meadow con un promedio de 32.05, siendo el más bajo de todos los barrios.
"""

df["Alley_value"]=df[["Alley"]].apply(lambda x: 3 if(x["Alley"]=="Grvl") else 2 if(x["Alley"]=="Pave") else 1 if(x["Alley"]=="NA") else 0, axis=1) 
df["Utilities_value"]=df[["Utilities"]].apply(lambda x: 4 if (x["Utilities"]=="AllPub") else 3 if(x["Utilities"]=="NoSewr") else 2 if(x["Utilities"]=="NoSeWa")else 1 if(x["Utilities"]=="ELO") else 0, axis=1) 
df["ExterQual_value"]=df[["ExterQual"]].apply(lambda x: 5 if (x["ExterQual"]=="Ex") else 4 if(x["ExterQual"]=="Gd") else 3 if(x["ExterQual"]=="TA") else 2 if(x["ExterQual"]=="Fa") else 1 if(x["ExterQual"]=="Po") else 0, axis=1)
df["ExterCond_value"]=df[["ExterCond"]].apply(lambda x: 5 if (x["ExterCond"]=="Ex") else 4 if(x["ExterCond"]=="Gd") else 3 if(x["ExterCond"]=="TA") else 2 if(x["ExterCond"]=="Fa") else 1 if(x["ExterCond"]=="Po") else 0, axis=1)
df["KitchenQual_value"]=df[["KitchenQual"]].apply(lambda x: 5 if (x["KitchenQual"]=="Ex") else 4 if(x["KitchenQual"]=="Gd") else 3 if(x["KitchenQual"]=="TA") else 2 if(x["KitchenQual"]=="Fa") else 1 if(x["KitchenQual"]=="Po") else 0, axis=1)
df["Functional_value"]=df[["Functional"]].apply(lambda x: 8 if (x["Functional"]=="Typ") else 7 if(x["Functional"]=="Min1") else 6 if(x["Functional"]=="Min2") else 5 if(x["Functional"]=="Mod") else 4 if(x["Functional"]=="Maj1") else 3 if(x["Functional"]=="Maj") else 2 if(x["Functional"]=="Sev") else 1 if(x["Functional"]=="Sal") else 0, axis=1)

"""Después de que se crearan las variables que asignan valor a las categóricas, se procederá a sumar todas para crear una nueva columna y así numéricamente poder determinar las casas que son mas desiguales."""

df["Ponderado_Desigualdad"]=df["Alley_value"]+df["Utilities_value"]+df["ExterQual_value"]+df["ExterCond_value"]+df["KitchenQual_value"]+df["Functional_value"]+df["OverallQual"]+df["OverallCond"]

"""A continuación, mediante un promedio por barrio, se determinará cuál es el barrio con mayor desigualdad."""

pd.DataFrame(df.groupby(["Neighborhood"])["Ponderado_Desigualdad"].mean()).sort_values(by="Ponderado_Desigualdad").head()

"""Se presentará una gráfica comparativa respecto a los demás barrios."""

pd.DataFrame(df.groupby(["Neighborhood"])["Ponderado_Desigualdad"].mean()).sort_values(by="Ponderado_Desigualdad").reset_index().plot.bar(x="Neighborhood", y="Ponderado_Desigualdad", title="Indicador de desigualdad", figsize=(20,4), color="r")

"""**¿En qué año hubo más movimiento del mercado inmobiliario?**

Para determinar el año con más ventas (movimiento) tomamos la variable YrSold e hicimos un conteo del número de ventas para ordenar de mayor a menor, dando como resultado que el año 2009 fue donde hubo más movimiento del mercado inmobiliario.
"""

pd.DataFrame(df.groupby(["YrSold"])["YrSold"].count()).rename(columns={"YrSold":"No de Ventas"}).reset_index().sort_values(by="No de Ventas", ascending=False)

pd.DataFrame(df.groupby(["YrSold"])["YrSold"].count()).rename(columns={"YrSold":"No de Ventas"}).reset_index().sort_values(by="YrSold", ascending=True).plot.bar(x="YrSold", y="No de Ventas", title="Ventas de casas por año", figsize=(13,6))

"""**¿Cuáles son los 2 barrios con mayor industria cerca?**

Para determinar los barrios con mayor industria cerca usamos la variable MSZoning, ya que las casas que están cerca de industria se identifican con "I". Inicialmente se verifica cuantas veces está "I" en el dataframe en la variable MSZoning.

Concluyendo entonces que de acuerdo a la data suministrada no hay casas ubicadas cerca a industria, es decir que son barrios netamente residenciales.
"""

df["MSZoning"].value_counts()

"""A continuación se presenta gráfico vacío."""

df["INDUSTRIA"]=df[["MSZoning"]].apply(lambda x: 1 if (x["MSZoning"]=="I") else 0, axis=1)
df.groupby(["Neighborhood"])["INDUSTRIA"].mean().reset_index().sort_values(by="INDUSTRIA",ascending=False).rename(columns={"INDUSTRIA":"CERCANÍA A INDUSTRIAS"}).head(10).plot.bar(x="Neighborhood", y="CERCANÍA A INDUSTRIAS", title="Barrios más cercanos a Industrias")

"""**¿Cuáles son los 2 barrios con mayor comercio cerca?**

Para esta pregunta  filtramos la base de datos por los barrios que tuvieran clasificacion en la venta como área comercial con la fila "MSZoning: Identifies the general zoning classification of the sale." , luego de esto hicimos un recuento de las casas de zona comercial en cada barrio y encontramos que los dos barrios con mayor comercio cerca son IDOTRR y OldTown
"""

df["COMERCIO"]=df[["MSZoning"]].apply(lambda x: 1 if (x["MSZoning"]=="C (all)") else 0, axis=1)
print("Los dos barrios con mayor comercio cerca son:")
df[df["COMERCIO"]==1]["Neighborhood"].value_counts()

df[df["COMERCIO"]==1]["Neighborhood"].value_counts().plot.bar()

